【1】复习
	platform总线
	
	设备端
		设备信息结构体：
		struct resource res[] = {
			[0] = {
				.start = 0xc0053000,
				.end   = 0xc0053000 + 24 -1,
				.flags = IORESOURCE_MEM,
			},
			[1] = {
				.start = 73,
				.end   = 73,
				.flags = IORESOURCE_IRQ,
			}
		};
		struct platform_device pdev = {
			.name = "hello",
			.id   = -1,
			.dev  = {
				.release = pdev_release,
			},
			.number_resource = 2,
			.resource = res,
		};
		platform_device_register(&pdev);
		platform_device_unregister(&pdev);
	
	驱动端
		struct platform_driver  pdrv = {
			.probe = pdrv_probe,
			.remove = pdrv_remove,
			.driver = {
				.name = "hello",
			},
			.id_table = pdrv_idtable,
		};
		
		platform_driver_register(&pdrv);
		platform_driver_unregister(&pdrv);
	
【2】i2c的驱动框架

user	
		open   read   write   close
------------------------------------------------------------------		
kernel	
	设备驱动层：当总线驱动和设备驱动匹配成功之后执行这里的probe函数
			1.注册字符设备驱动，给应用层提供访问的接口
			2.封装数据，发送数据（i2c_read_reg,i2c_write_reg）
			3.完成硬件（mma8451q）的初始化	
	-------------------------------------------------------------
	核心层(i2c-core.c )：它是由linux内核工程师实现的，提供总线驱
		动和设备驱动的注册和注销的方式，以及匹配的过程。
	-------------------------------------------------------------
	总线驱动层（控制器驱动层）：在linux内核中厂商已经将控制器驱动
drivers/i2c/busses|编写好了，对控制器的初始化，数据的发送和接收。
	i2c-s3c241.c  |
------------------|-----------------------------------------------
hardware ：	i2c控制器                         mma8451q
		    ------------	scl            ------------
			|          |-------------------|   x      |
			|          |    sda            |   y      |
			|          |-------------------|   z      |
			|		   |                   |		  |
			------------                   ------------
	
	
	 // s3c2410  s3c6410  s5pv210   exynos4412   s5p6818

	