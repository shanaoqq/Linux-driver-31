【1】复习
	1.字符设备驱动的框架
		inode结构体：只要一个文件在linux系统中存在
					就会有一个inode结构体和这个文件对应。
					这个inode结构体时描述这个文件的各种
					属性信息，驱动 ，设备号等
		file结构体：只要通过open函数打开文件就会产生
					file，这个file结构体就会保存在fd_array
					数组中，这个数组下标就是fd，file结构体
					是用来描述打开文件时候的各种信息。
	2.字符设备驱动实现
		1.分配cdev的对象
			struct cdev*cdev = cdev_alloc();
		2.cdev结构体的初始化
			cdev_init(cdev,&fops);
		3.申请设备号
			静态申请设备号：
			register_chrdev_region();
			动态申请设备号：
			alloc_chrdev_region();
		4.字符设备驱动的注册
			cdev_add();
		----------------------------
		5.字符设备驱动的注销
			cdev_del();
		6.注销设备号
			unregister_chrdev_region();
		7.释放内存
			kfree(cdev);
			
		
	练习：
		1.练习ADC字符设备驱动（15分钟）
		
【2】Linux内核并发和竞态的解决方法
	竞态：应用层多个进程可以同时访问同一个驱动同一
		  个资源（临界资源），这时候就会产生竞态。
	
	竞态产生的根本原因：
		1.对于单cpu的内核支持抢占
		2.多核cpu,核与核之间就会有竞态
		3.进程和中断也会产生竞态
		4.中断和中断间竞态？
		
	解决竞态的方式：
		1.顺序执行
		2.互斥执行
	
	竞态的解决方法（互斥执行）：
		1.中断屏蔽（了解）
			中断屏蔽只适合用在单核cpu上，原因和进程和
			进程间的抢占以及中断和进程间的竞态的产生
			都是由中断来完成的。所以将中断屏蔽了，就可
			解决竞态。
			
			中断屏蔽的时间要尽可能的短，如果中断屏蔽的
			时间很长，它可能导致内核的崩溃或用户数据的
			丢失等。
			
			使用的方法如下：
			local_irq_disable();
			//临界资源
			local_irq_enable();
				
		2.自旋锁（重点掌握）
			特性：当一个进程获取到自旋锁之后，另外一个
			进程也想或者这把锁，此时它（第二个进程）处
			于自旋状态（原地打转）。
			
			自旋锁使用的注意事项：
			1.自旋锁是针对多核cpu设计的
			2.自旋锁会消耗cpu
			3.自旋锁上锁的时间尽可能的短，临界资源
			执行时间要尽可能的短。如果临界资源占用
			时间很长可能会导致内核的崩溃等，在临界区
			内不能使用延时，耗时，copy_to/from_user等函数。
			4.自旋锁可能导致死锁 ，在同一个进程内多次
			获取同一把未释放的锁。（锁死的是cpu）
			5.自旋锁在上锁的时候会关闭抢占
			
			API:
			1.定义锁
				spinlock_t lock;
			2.初始化锁
				spin_lock_init(&lock);
			3.上锁
				void spin_lock(spinlock_t *lock)
			4.解锁
				void spin_unlock(spinlock_t *lock)
			
			
			
			
			
		3.信号量（重点掌握）
		4.互斥体（掌握）
		5.原子操作（掌握）
		
		
		
		
		
		